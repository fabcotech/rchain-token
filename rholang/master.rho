new 
  basket,

  entryCh,
  entryUriCh,

  makePurseCh,
  transferToEscrowPurseCh,
  calculateFeeCh,
  initializeOCAPOnBoxCh,

  initLocksForContractCh,
  initLocksForBoxCh,

  /*
    vault is the ultimate accessibility unforgeable in
    master contract, every data is stored in channels that
    derives from *vault unforgeable name

    // tree hash map of purses :
    thm <- @(*vault, "purses", "contract03")

    // tree hash map of purses data :
    thm <- @(*vault, "pursesData", "contract03")

    // contract's configs
    config <- @(*vault, "contractConfig", "contract03")

    // box's configs
    config <- @(*vault, "boxConfig", "box01")

    // boxes (rholang Map)
    box <- @(*vault, "boxes", "box01")

    // super keys of a given box
    superKeys <- @(*vault, "boxesSuperKeys", "box01")
  */
  vault,

  /*
    boxesThm and contractsThm only store the list
    of existing contracts / boxes, ex:
    boxesThm:
    { "box1": "exists", "mycoolbox": "exists" }

    Then each box is a Map stored at a unique channel
    (see above) and has the following structure:
    {
      [contractId: string]: Set(purseId: string)
    }

    Each contract has its own tree hash map, and
    have the following structure:
    pursesThm, example of FT purses:
    {
      "1": { quantity: 2, timestamp: 12562173658, type: "0", boxId: "box1", price: Nil},
      "2": { quantity: 12, timestamp: 12562173658, type: "0", boxId: "box1", price: 2},
    }
  */
  boxesReadyCh,
  contractsReadyCh,

  TreeHashMap,

  savePurseInBoxCh,
  removePurseInBoxCh,
  getBoxCh,
  getPurseCh,
  getContractPursesThmCh,
  getContractPursesDataThmCh,

  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  revAddress(`rho:rev:address`),
  registryLookup(`rho:registry:lookup`),
  blockData(`rho:block:data`)
in {

  TREE_HASH_MAP

  // depth 1 = 12 maps in tree hash map
  // depth 2 = 12 * 12 = 144 maps in tree hash map
  // etc...

  // WITHDRAW, PURCHASE and CREATE_PURSE can touch the same boxes or
  // purses, we cannot allow concurrency because we want to avoid
  // race conditions

  for (@boxId <= initLocksForBoxCh) {
    @(*vault, "RENEW_LOCK", boxId)!(Nil) |
    @(*vault, "UPDATE_PURSE_PRICE_LOCK", boxId)!(Nil) |
    @(*vault, "UPDATE_PURSE_DATA_LOCK", boxId)!(Nil) |
    @(*vault, "REGISTER_CONTRACT_LOCK", boxId)!(Nil)
  } |

  for (@contractId <= initLocksForContractCh) {
    @(*vault, "CONTRACT_LOCK", contractId)!(Nil)
  } |

  TreeHashMap!("init", DEPTH, true, *boxesReadyCh) |
  TreeHashMap!("init", DEPTH, false, *contractsReadyCh) |

  for (@boxesThm <- boxesReadyCh; @contractsThm <- contractsReadyCh) {

    // returns the box if exists
    for (@(boxId, return) <= getBoxCh) {
      new ch1 in {
        TreeHashMap!("get", boxesThm, boxId, *ch1) |
        for (@exists <- ch1) {
          if (exists == "exists") {
            for (@box <<- @(*vault, "boxes", boxId)) {
              @return!(box)
            }
          } else {
            @return!(Nil)
          }
        }
      }
    } |

    // returns the purse if exists AND is associated with box
    for (@(box, contractId, purseId, return) <= getPurseCh) {
      new ch1 in {
        if (box.get(contractId) == Nil) {
          @return!(Nil)
        } else {
          if (box.get(contractId).contains(purseId) == true) {
            getContractPursesThmCh!((contractId, *ch1)) |
            for (@pursesThm <- ch1) {
              TreeHashMap!("get", pursesThm, purseId, return)
            }
          } else {
            @return!(Nil)
          }
        }
      }
    } |

    // returns the tree hash map of the contract's purses if exists
    for (@(contractId, return) <= getContractPursesThmCh) {
      new ch1 in {
        TreeHashMap!("get", contractsThm, contractId, *ch1) |
        for (@exists <- ch1) {
          if (exists == "exists") {
            for (@pursesThm <<- @(*vault, "purses", contractId)) {
              @return!(pursesThm)
            }
          } else {
            @return!(Nil)
          }
        }
      }
    } |

    // returns the tree hash map of the contract's purses data if exists
    for (@(contractId, return) <= getContractPursesDataThmCh) {
      new ch1 in {
        TreeHashMap!("get", contractsThm, contractId, *ch1) |
        for (@exists <- ch1) {
          if (exists == "exists") {
            for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {
              @return!(pursesDataThm)
            }
          } else {
            @return!(Nil)
          }
        }
      }
    } |
  
    // remove purse in box, if found
    for (@(boxId, contractId, purseId, return) <= removePurseInBoxCh) {
      for (@box <- @(*vault, "boxes", boxId)) {
        if (box.get(contractId) == Nil) {
          @return!("error: CRITICAL purse not found") |
          @(*vault, "boxes", boxId)!(box)
        } else {
          if (box.get(contractId).contains(purseId) == false) {
            @return!("error: CRITICAL purse already exists in box") |
            @(*vault, "boxes", boxId)!(box)
          } else {
            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " removed from box") |
            @(*vault, "boxes", boxId)!(box.set(contractId, box.get(contractId).delete(purseId))) |
            @return!((true, Nil))
          }
        }
      }
    } |

    // save purse id in box
    for (@(contractId, boxId, purseId, merge, return) <= savePurseInBoxCh) {
      new ch1, ch3, iterateAndMergePursesCh in {

        for (@box <- @(*vault, "boxes", boxId)) {
          getContractPursesThmCh!((contractId, *ch1)) |
          for (@pursesThm <- ch1) {
            if (pursesThm != Nil) {
              if (box.get(contractId) == Nil) {
                stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |
                @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |
                @return!((true, Nil))
              } else {
                if (box.get(contractId).contains(purseId) == false) {
                  for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {
                    match (contractConfig.get("fungible") == true, merge) {
                      (true, true) => {
                        for (@pursesThm <<- @(*vault, "purses", contractId)) {
                          TreeHashMap!("get", pursesThm, purseId, *ch3) |
                          for (@purse <- ch3) {
                            iterateAndMergePursesCh!((box, purse, pursesThm))
                          }
                        }
                      }
                      _ => {
                        stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |
                        @(*vault, "boxes", boxId)!(box.set(
                          contractId,
                          box.get(contractId).union(Set(purseId))
                        )) |
                        @return!((true, Nil))
                      }
                    }
                  }
                } else {
                  @(*vault, "boxes", boxId)!(box) |
                  @return!("error: CRITICAL, purse already exists in box")
                }
              }
            } else {
              @(*vault, "boxes", boxId)!(box) |
              @return!("error: CRITICAL, pursesThm not found")
            }
          }
        } |
        // if contract is fungible, we may find a
        // purse with same .price and .type property
        // if found, then merge and delete current purse
        for (@(box, purse, pursesThm) <- iterateAndMergePursesCh) {
          new tmpCh, itCh in {
            for (ids <= itCh) {
              match *ids {
                Set() => {
                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |
                  @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |
                  @return!((true, Nil))
                }
                Set(last) => {
                  new ch4, ch5, ch6, ch7 in {
                    TreeHashMap!("get", pursesThm, last, *ch4) |
                    for (@purse2 <- ch4) {
                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {
                        (true, true) => {
                          TreeHashMap!(
                            "set",
                            pursesThm,
                            last,
                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),
                            *ch5
                          ) |
                          TreeHashMap!(
                            "set",
                            pursesThm,
                            purse.get("id"),
                            Nil,
                            *ch6
                          ) |
                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {
                            TreeHashMap!(
                              "set",
                              pursesDataThm,
                              purse.get("id"),
                              Nil,
                              *ch7
                            )
                          } |
                          for (_ <- ch5; _ <- ch6; _ <- ch7) {
                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |
                            @return!((true, Nil)) |
                            @(*vault, "boxes", boxId)!(box)
                          }
                        }
                        _ => {
                          stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |
                          @(*vault, "boxes", boxId)!(box.set(
                            contractId,
                            box.get(contractId).union(Set(purse.get("id")))
                          )) |
                          @return!((true, Nil)) |
                          @(*vault, "boxes", boxId)!(box)
                        }
                      }
                    }

                  }
                }
                Set(first ... rest) => {
                  new ch4, ch5, ch6, ch7 in {
                    TreeHashMap!("get", pursesThm, first, *ch4) |
                    for (@purse2 <- ch4) {
                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {
                        (true, true) => {
                          TreeHashMap!(
                            "set",
                            pursesThm,
                            first,
                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),
                            *ch5
                          ) |
                          TreeHashMap!(
                            "set",
                            pursesThm,
                            purse.get("id"),
                            Nil,
                            *ch6
                          ) |
                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {
                            TreeHashMap!(
                              "set",
                              pursesDataThm,
                              purse.get("id"),
                              Nil,
                              *ch7
                            )
                          } |
                          for (_ <- ch5; _ <- ch6; _ <- ch7) {
                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |
                            @return!((true, Nil)) |
                            @(*vault, "boxes", boxId)!(box)
                          }
                        }
                        _ => {
                          itCh!(rest)
                        }
                      }
                    }
                  }
                }
              }
            } |
            itCh!(box.get(contractId))
          }
        }
      }
    } |

    /*
      makePurseCh
      only place where new purses are created:
      PURCHASE, WITHDRAW, and CREATE_PURSE may call this channel

      depending on if .fungible is true or false, it decides
      which id to give to the new purse, then it creates the
      purse and saves to box
    */
    for (@(contractId, properties, data, merge, return) <= makePurseCh) {
      new ch1, ch2, ch3, ch4, idAndQuantityCh in {
        for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {
          if (contractConfig.get("fungible") == true) {
            for (_ <- @(*vault, "contractConfig", contractId)) {
              @(*vault, "contractConfig", contractId)!(contractConfig.set("counter", contractConfig.get("counter") + 1))
            } |
            idAndQuantityCh!({ "id": "${n}" %% { "n": contractConfig.get("counter") }, "quantity": properties.get("quantity") })
          } else {
            for (@pursesThm <<- @(*vault, "purses", contractId)) {
              TreeHashMap!("get", pursesThm, properties.get("id"), *ch1) |
              for (@existingPurse <- ch1) {

                // check that nft does not exist
                if (existingPurse == Nil) {
                  if (properties.get("id") == "0") {
                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": properties.get("quantity") })
                  } else {
                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": 1 })
                  }
                } else {

                  // nft with id: "0" is a special nft from which
                  // anyone can mint a nft that does not exist yet
                  // used by dappy name system for example
                  if (properties.get("id") == "0") {
                    TreeHashMap!("get", pursesThm, properties.get("newId"), *ch2) |
                    for (@purseWithNewId <- ch2) {
                      match (properties.get("newId"), purseWithNewId) {
                        (String, Nil) => {
                          idAndQuantityCh!({ "id": properties.get("newId"), "quantity": 1 })
                        }
                        _ => {
                          @return!("error: no .newId in payload or .newId already exists")
                        }
                      }
                    }
                  } else {
                    @return!("error: purse id already exists")
                  }
                }
              }
            }
          }
        } |
        for (@idAndQuantity <- idAndQuantityCh) {
          match properties
            .set("id", idAndQuantity.get("id"))
            .set("quantity", idAndQuantity.get("quantity"))
            .delete("newId")
          {
            purse => {
              match (purse, purse.get("id").length() > 0, purse.get("id").length() < 25) {
                ({
                  "quantity": Int,
                  "timestamp": Int,
                  "type": String,
                  "boxId": String,
                  "id": String,
                  "price": Nil \/ Int
                }, true, true) => {
                  for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {
                    for (@pursesThm <<- @(*vault, "purses", contractId)) {
                      TreeHashMap!("set", pursesThm, purse.get("id"), purse, *ch3) |
                      TreeHashMap!("set", pursesDataThm, purse.get("id"), data, *ch4)
                    }
                  } |

                  for (_ <- ch3; _ <- ch4) {
                    savePurseInBoxCh!((contractId, purse.get("boxId"), purse.get("id"), merge, return))
                  }
                }
                _ => {
                  @return!("error: invalid purse, one of the following errors: id length must be between length 1 and 24")
                }
              }
            }
          }
        }
      }
    } |

    // ====================================
    // ===== ANY USER / PUBLIC capabilities
    // ====================================

    for (@("PUBLIC_READ_PURSES_AT_INDEX", contractId, i, return) <= entryCh) {
      new ch1 in {
        getContractPursesThmCh!((contractId, *ch1)) |
        for (@pursesThm <- ch1) {
          if (pursesThm == Nil) {
            @return!("error: contract not found")
          } else {
            TreeHashMap!("getValuesAtIndex", pursesThm, i, return)
          }
        }
      }
    } |

    for (@("PUBLIC_READ_CONFIG", contractId, return) <= entryCh) {
      for (@config <<- @(*vault, "contractConfig", contractId)) {
        @return!(config)
      }
    } |

    for (@("PUBLIC_READ_BOX", boxId, return) <= entryCh) {
      new ch1 in {
        getBoxCh!((boxId, *ch1)) |
        for (@box <- ch1) {
          if (box == Nil) {
            @return!("error: box not found")
          } else {
            for (@superKeys <<- @(*vault, "boxesSuperKeys", boxId)) {
              for (@config <<- @(*vault, "boxConfig", boxId)) {
                @return!(config.union({ "superKeys": superKeys, "purses": box, "version": VERSION }))
              }
            }
          }
        }
      }
    } |

    for (@("PUBLIC_READ_PURSE", payload, return) <= entryCh) {
      new ch1 in {
        getContractPursesThmCh!((payload.get("contractId"), *ch1)) |
        for (@pursesThm <- ch1) {
          if (pursesThm == Nil) {
            @return!("error: contract not found")
          } else {
            match payload.get("purseId") {
              String => {
                TreeHashMap!("get", pursesThm, payload.get("purseId"), return)
              }
              _ => {
                @return!("error: payload.purseId must be a string")
              }
            }
          }
        }
      }
    } |

    for (@("PUBLIC_READ_PURSE_DATA", payload, return) <= entryCh) {
      new ch1 in {
        getContractPursesDataThmCh!((payload.get("contractId"), *ch1)) |
        for (@pursesDataThm <- ch1) {
          if (pursesDataThm == Nil) {
            @return!("error: contract not found")
          } else {
            match payload.get("purseId") {
              String => {
                TreeHashMap!("get", pursesDataThm, payload.get("purseId"), return)
              }
              _ => {
                @return!("error: payload.purseId must be a string")
              }
            }
          }
        }
      }
    } |

    for (@("PUBLIC_DELETE_EXPIRED_PURSE", contractId, purseId, return) <= entryCh) {
      for (@config <<- @(*vault, "contractConfig", contractId)) {
        match (config.get("fungible"), purseId == "0", config.get("expires")) {
          (false, false, Int) => {
            new ch1, ch2, ch3, ch4, ch5, ch6, ch7 in {
              getContractPursesThmCh!((contractId, *ch1)) |
              getContractPursesDataThmCh!((contractId, *ch2)) |
              for (@pursesThm <- ch1; @pursesDataThm <- ch2) {
                if (pursesThm == Nil) {
                  @return!("error: contract not found")
                } else {
                  TreeHashMap!("get", pursesThm, purseId, *ch3) |
                  for (@purse <- ch3) {
                    if (purse == Nil) {
                      @return!("error: purse not found")
                    } else {
                      blockData!(*ch4) |
                      for (_, @timestamp, _ <- ch4) {
                        if (timestamp - purse.get("timestamp") > config.get("expires")) {
                          TreeHashMap!("set", pursesThm, purse.get("id"), Nil, *ch5) |
                          TreeHashMap!("set", pursesDataThm, purse.get("id"), Nil, *ch6) |
                          removePurseInBoxCh!((purse.get("boxId"), contractId, purse.get("id"), *ch7)) |
                          for (_ <- ch5; _ <- ch6; _ <- ch7) {
                            @return!((true, Nil))
                          }
                        } else {
                          @return!("error: purse has not expired")
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          _ => {
            @return!("error: contract must not be fungible, and must have .expires property")
          }
        }
      }
    } |

    for (@("PUBLIC_REGISTER_BOX", payload, return) <= entryCh) {
      match (payload.get("boxId"), payload.get("publicKey"), payload.get("boxId").length() > 1, payload.get("boxId").length() < 25) {
        (String, String, true, true) => {
          new ch1, ch2, ch3, ch4, ch5, ch6 in {
            registryLookup!(`rho:rchain:revVault`, *ch3) |
            for (@(_, RevVault) <- ch3) {
              revAddress!("fromPublicKey", payload.get("publicKey").hexToBytes(), *ch4) |
              for (@a <- ch4) {
                @RevVault!("findOrCreate", a, *ch5) |
                for (@b <- ch5) {
                  match b {
                    (true, vaultFromPublicKey) => {
                      ch6!(true)
                    }
                    _ => {
                      @return!("error: invalid public key, could not get vault")
                    }
                  }
                }
              }
            } |

            TreeHashMap!("get", boxesThm, payload.get("boxId"), *ch1) |
            for (@existingBox <- ch1; _ <- ch6) {
              if (existingBox == Nil) {
                new boxCh in {
                  TreeHashMap!("set", boxesThm, payload.get("boxId"), "exists", *ch2) |
                  for (_ <- ch2) {
                    @(*vault, "boxes", payload.get("boxId"))!({}) |
                    @(*vault, "boxesSuperKeys", payload.get("boxId"))!(Set()) |
                    @(*vault, "boxConfig", payload.get("boxId"))!({ "publicKey": payload.get("publicKey") }) |
                    @return!((true, bundle+{*boxCh})) |
                    initLocksForBoxCh!(payload.get("boxId")) |
                    initializeOCAPOnBoxCh!((*boxCh, payload.get("boxId")))
                  }
                }
              } else {
                @return!("error: box already exists")
              }
            }
          }
        }
      }
    } |

    for (@(boxCh, boxId) <= initializeOCAPOnBoxCh) {

      for (@("REGISTER_CONTRACT", payload, return) <= @boxCh) {
        for (_ <- @(*vault, "REGISTER_CONTRACT_LOCK", boxId)) {
          new registerContract, ch1, ch2, ch3, ch4, ch5, unlock in {
            for (@result <- unlock) {
              @(*vault, "REGISTER_CONTRACT_LOCK", boxId)!(Nil) |
              @return!(result)
            } |
            match payload {
              { "contractId": String, "fungible": Bool, "fee": Nil \/ (String, Int), "expires": Nil \/ Int } => {
                match (payload.get("contractId").length() > 1, payload.get("contractId").length() < 25) {
                  (true, true) => {
                    if (payload.get("expires") == Nil) {
                      registerContract!(Nil)
                    } else {
                      // minimum 2 hours expiration
                      if (payload.get("expires") >= 1000 * 60 * 60 * 2) {
                        registerContract!(Nil)
                      } else {
                        unlock!("error: .expires must be at least 2 hours")
                      }
                    }
                  }
                  _ => {
                    unlock!("error: invalid contract id")
                  }
                }
              }
              _ => {
                unlock!("error: invalid payload")
              }
            } |
            for (_ <- registerContract) {
              TreeHashMap!("get", contractsThm, payload.get("contractId"), *ch1) |
              for (@exists <- ch1) {
                if (exists == Nil) {
                  TreeHashMap!("init", DEPTH_CONTRACT, true, *ch2) |
                  TreeHashMap!("init", DEPTH_CONTRACT, true, *ch4) |
                  TreeHashMap!("set", contractsThm, payload.get("contractId"), "exists", *ch3) |
                  for (@pursesThm <- ch2; @pursesDataThm <- ch4; _ <- ch3) {

                    for (@superKeys <- @(*vault, "boxesSuperKeys", boxId)) {
                      @(*vault, "boxesSuperKeys", boxId)!(
                        superKeys.union(Set(payload.get("contractId")))
                      )
                    } |

                    // purses tree hash map
                    @(*vault, "purses", payload.get("contractId"))!(pursesThm) |

                    // purses data tree hash map
                    @(*vault, "pursesData", payload.get("contractId"))!(pursesDataThm) |

                    // config
                    @(*vault, "contractConfig", payload.get("contractId"))!(
                      payload.set("locked", false).set("counter", 1).set("version", VERSION).set("fee", payload.get("fee"))
                    ) |

                    new superKeyCh in {
                      // return the bundle+ super key
                      unlock!((true, bundle+{*superKeyCh})) |
                      initLocksForContractCh!(payload.get("contractId")) |

                      for (@("LOCK", return2) <= superKeyCh) {
                        for (_ <- @(*vault, "CONTRACT_LOCK", payload.get("contractId"))) {
                          for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {
                            if (contractConfig.get("locked") == true) {
                              @return2!("error: contract is already locked") |
                              @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
                            } else {
                              for (_ <- @(*vault, "contractConfig", payload.get("contractId"))) {
                                @(*vault, "contractConfig", payload.get("contractId"))!(contractConfig.set("locked", true)) |
                                @return2!((true, Nil)) |
                                @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
                              }
                            }
                          }
                        }
                      } |

                      for (@("CREATE_PURSE", createPursePayload, return2) <= superKeyCh) {
                        for (_ <- @(*vault, "CONTRACT_LOCK", payload.get("contractId"))) {
                          for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {
                            if (contractConfig.get("locked") == true) {
                              @return2!("error: contract is locked") |
                              @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
                            } else {
                              new blockDataCh, ch1, ch2 in {
                                blockData!(*blockDataCh) |
                                for (_, @timestamp, _ <- blockDataCh) {
                                  match (createPursePayload, createPursePayload.get("price") == 0) {
                                    ({
                                      "data": _,
                                      "quantity": Int,
                                      "type": String,
                                      "id": String,
                                      "price": Nil \/ Int,
                                      "boxId": String
                                    }, false) => {
                                      getBoxCh!((createPursePayload.get("boxId"), *ch1)) |
                                      for (@box <- ch1) {
                                        if (box == Nil) {
                                          @return2!("error: box not found " ++ createPursePayload.get("boxId")) |
                                          @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
                                        } else {
                                          makePurseCh!((
                                            payload.get("contractId"),
                                            createPursePayload.delete("data").set("timestamp", timestamp),
                                            createPursePayload.get("data"),
                                            true,
                                            *ch2
                                          )) |
                                          for (@r <- ch2) {
                                            @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil) |
                                            match r {
                                              String => {
                                                @return2!(r)
                                              }
                                              _ => {
                                                @return2!(true)
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    _ => {
                                      @return2!("error: invalid purse payload") |
                                      @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  unlock!("error: contract id already exists")
                }
              }
            }
          }
        }
      } |

      for (@("UPDATE_PURSE_PRICE", payload, return) <= @boxCh) {
        for (_ <- @(*vault, "UPDATE_PURSE_PRICE_LOCK", boxId)) {
          new ch3, ch4, ch5, unlock in {
            for (@result <- unlock) {
              @(*vault, "UPDATE_PURSE_PRICE_LOCK", boxId)!(Nil) |
              @return!(result)
            } |
            match (payload, payload.get("price") == 0) {
              ({ "price": Int \/ Nil, "contractId": String, "purseId": String }, false) => {
                getBoxCh!((boxId, *ch3)) |
                for (@box <- ch3) {
                  if (box != Nil) {
                    getPurseCh!((box, payload.get("contractId"), payload.get("purseId"), *ch4)) |
                    for (@purse <- ch4) {
                      if (purse != Nil) {
                        for (@pursesThm <<- @(*vault, "purses", payload.get("contractId"))) {
                          TreeHashMap!("set", pursesThm, payload.get("purseId"), purse.set("price", payload.get("price")), *ch5) |
                          for (_ <- ch5) {
                            unlock!((true, Nil))
                          }
                        }
                      } else {
                        unlock!("error: purse not found")
                      }
                    }
                  } else {
                    unlock!("error: CRITICAL box not found")
                  }
                }
              }
              _ => {
                unlock!("error: invalid payload for update price")
              }
            }
          }
        }
      } |

      for (@("UPDATE_PURSE_DATA", payload, return) <= @boxCh) {
        for (_ <- @(*vault, "UPDATE_PURSE_DATA_LOCK", boxId)) {
          new ch3, ch4, ch5, unlock in {
            for (@result <- unlock) {
              @(*vault, "UPDATE_PURSE_DATA_LOCK", boxId)!(Nil) |
              @return!(result)
            } |
            match payload {
              { "data": _, "contractId": String, "purseId": String } => {
                getBoxCh!((boxId, *ch3)) |
                for (@box <- ch3) {
                  if (box != Nil) {
                    getPurseCh!((box, payload.get("contractId"), payload.get("purseId"), *ch4)) |
                    for (@purse <- ch4) {
                      if (box != Nil) {
                        for (@pursesDataThm <<- @(*vault, "pursesData", payload.get("contractId"))) {
                          TreeHashMap!("set", pursesDataThm, payload.get("purseId"), payload.get("data"), *ch5) |
                          for (_ <- ch5) {
                            unlock!((true, Nil))
                          }
                        }
                      } else {
                        unlock!("error: purse not found")
                      }
                    }
                  } else {
                    unlock!("error: CRITICAL box not found")
                  }
                }
              }
              _ => {
                unlock!("error: invalid payload for update data")
              }
            }
          }
        }
      } |

      for (@("RENEW", payload, return) <= @boxCh) {
        for (_ <- @(*vault, "RENEW_LOCK", boxId)) {
          new ch1, ch2, ch3, ch4, renewStep2, ch20, renewStep3, ch30, ch31, ch32, ch33, ch34, ch35, ch36, unlock in {
            for (@result <- unlock) {
              @(*vault, "RENEW_LOCK", boxId)!(Nil) |
              @return!(result)
            } |
            match payload {
              { "contractId": String, "purseId": String, "purseRevAddr": String, "purseAuthKey": _ } => {
                getBoxCh!((boxId, *ch1)) |
                for (@box <- ch1) {
                  if (box != Nil) {
                    getContractPursesThmCh!((payload.get("contractId"), *ch2)) |
                    getPurseCh!((box, payload.get("contractId"), payload.get("purseId"), *ch3)) |

                    for (@pursesThm <- ch2) {
                      if (pursesThm == Nil) {
                        unlock!("error: CRITICAL tree hash map not found")
                      } else {
                        TreeHashMap!("get", pursesThm, "0", *ch4)
                      } |
                      for (@purse <- ch3; @purseZero <- ch4) {
                        for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {
                          match (contractConfig.get("expires"), contractConfig.get("fungible") == false, purse != Nil, purseZero != Nil) {
                            (Int, true, true, true) => {
                              renewStep2!((pursesThm, purseZero, purse, contractConfig.get("expires")))
                            }
                            _ => {
                              unlock!("error: purse 0 not found or contract is fungible=true")
                            }
                          }
                        }
                      }
                    }
                  } else {
                    unlock!("error: CRITICAL box not found")
                  }
                }
              }
              _ => {
                unlock!("error: invalid payload for renew")
              }
            } |

            for (@(pursesThm, purseZero, purse, expires) <- renewStep2) {
              blockData!(*ch20) |
              for (_, @timestamp, _ <- ch20) {
                match expires / 10 {
                  grace => {
                    match purse.get("timestamp") + expires - grace {
                      startOfGracePeriod => {
                        if (timestamp > startOfGracePeriod) {
                          renewStep3!((pursesThm, purseZero, purse, expires))
                        } else {
                          unlock!("error: to soon to renew")
                        }
                      }
                      _ => {
                        unlock!("error: cannot calculate grace period")
                      }
                    }
                  }
                  _ => {
                    unlock!("error: cannot calculate grace period")
                  }
                }
              }
            } |

            for (@(pursesThm, purseZero, purse, expires) <- renewStep3) {
              for (@boxConfig <<- @(*vault, "boxConfig", purseZero.get("boxId"))) {
                registryLookup!(`rho:rchain:revVault`, *ch33) |
                for (@(_, RevVault) <- ch33) {
                  @RevVault!("findOrCreate", payload.get("purseRevAddr"), *ch34) |
                  revAddress!("fromPublicKey", boxConfig.get("publicKey").hexToBytes(), *ch32)
                }
              } |

              for (@revAddr <- ch32; @r <- ch34) {
                match r {
                  (true, purseVaultEmitter) => {
                    if (purseZero.get("price") == Nil) {
                      @purseVaultEmitter!("transfer", revAddr, 1, payload.get("purseAuthKey"), *ch35)
                    } else if (purseZero.get("price") == 0) {
                      @purseVaultEmitter!("transfer", revAddr, 1, payload.get("purseAuthKey"), *ch35)
                    } else {
                      @purseVaultEmitter!("transfer", revAddr, purseZero.get("price"), payload.get("purseAuthKey"), *ch35)
                    }
                  }
                  _ => {
                    unlock!("error: could not find vaule from rev address")
                  }
                }
              } |

              for (@paymentResult <- ch35) {
                match paymentResult {
                  (true, Nil) => {
                    TreeHashMap!("set", pursesThm, purse.get("id"), purse.set("timestamp", purse.get("timestamp") + expires), *ch36) |
                    for (_ <- ch36) {
                      unlock!((true, Nil))
                    }
                  }
                  _ => {
                    unlock!("error: failed to execute payment")
                  }
                }
              }
            }
          }
        }
      } |

      for (@("WITHDRAW", payload, return) <= @boxCh) {
        // todo can we have a lock that is only
        // scoped to fromBox and toBox ?
        new ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, proceedWithdrawCh, mergeCh, mergeOkCh, unlock in {
          for (@result <- unlock) {
            @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil) |
            @return!(result)
          } |
          match payload {
            { "quantity": Int, "contractId": String, "purseId": String, "toBoxId": String, "merge": Bool } => {
              getContractPursesThmCh!((payload.get("contractId"), *ch4)) |
              getBoxCh!((payload.get("toBoxId"), *ch6)) |
              getBoxCh!((boxId, *ch10)) |
              for (@pursesThm <- ch4; @toBox <- ch6; @box <- ch10) {
                match (pursesThm != Nil, toBox != Nil, box != Nil) {
                  (true, true, true) => {
                    getPurseCh!((box, payload.get("contractId"), payload.get("purseId"), *ch9)) |
                    for (@purse <- ch9) {
                      if (purse == Nil) {
                        @return!("error: purse does not exist")
                      } else {
                        if (purse.get("id") != "0") {
                          for (_ <- @(*vault, "CONTRACT_LOCK", payload.get("contractId"))) {
                            proceedWithdrawCh!((pursesThm, purse))
                          }
                        } else {
                          @return!("error: withdraw from special nft 0 is forbidden")
                        }
                      }
                    }
                  }
                  _ => {
                    @return!("error: contract or recipient box does not exist")
                  }
                }
              }
            }
            _ => {
              @return!("error: invalid payload for withdraw")
            }
          } |

          for (@(pursesThm, purse) <- proceedWithdrawCh) {

            // the withdrawer should not be able to choose if
            // tokens in recipient box will or will not be 
            // merged, except if he withdraws to himself
            mergeCh!(payload.get("merge")) |
            if (payload.get("toBoxId") != boxId) {
              for (_ <- mergeCh) {
                mergeOkCh!(true)
              }
            } else {
              for (@m <- mergeCh) {
                mergeOkCh!(m)
              }
            } |

            for (@merge <- mergeOkCh) {
              match (
                purse.get("quantity") - payload.get("quantity") >= 0,
                purse.get("quantity") > 0,
                purse.get("quantity") - payload.get("quantity") > 0
              ) {

                // ajust quantity in first purse, create a second purse
                // associated with toBoxId
                (true, true, true) => {
                  TreeHashMap!("set", pursesThm, payload.get("purseId"), purse.set("quantity", purse.get("quantity") - payload.get("quantity")), *ch5) |
                  for (_ <- ch5) {
                    makePurseCh!((
                      payload.get("contractId"),
                      purse
                        .set("price", Nil)
                        .set("quantity", payload.get("quantity"))
                        .set("boxId", payload.get("toBoxId")),
                      Nil,
                      merge,
                      *unlock
                    ))
                  }
                }

                // remove first purse, create a second purse
                // associated with toBoxId
                (true, true, false) => {
                  TreeHashMap!("set", pursesThm, payload.get("purseId"), Nil, *ch5) |
                  for (@pursesDataThm <<- @(*vault, "pursesData", payload.get("contractId"))) {
                    TreeHashMap!(
                      "get",
                      pursesDataThm,
                      payload.get("purseId"),
                      *ch7
                    ) |
                    for (_ <- ch5; @data <- ch7) {
                      TreeHashMap!(
                        "set",
                        pursesDataThm,
                        payload.get("purseId"),
                        Nil,
                        *ch11
                      ) |
                      for (_ <- ch11) {
                        removePurseInBoxCh!((boxId, payload.get("contractId"), payload.get("purseId"), *ch8)) |
                        for (@r <- ch8) {
                          match r {
                            String => {
                              unlock!(r)
                            }
                            _ => {
                              makePurseCh!((
                                payload.get("contractId"),
                                purse
                                  .set("price", Nil)
                                  .set("boxId", payload.get("toBoxId")),
                                data,
                                merge,
                                *unlock
                              ))
                            }
                          }
                        }
                      }
                    }
                  }
                }
                _ => {
                  unlock!("error: cannot withdraw, quantity in payload is superior to existing purse quantity")
                }
              }
            }
          }
        }
      } |

      // keep review from here

      for (@(amount, contractConfig, return2) <= calculateFeeCh) {
        if (contractConfig.get("fee") == Nil) {
          @return2!((amount, 0, Nil))
        } else {
          match amount * contractConfig.get("fee").nth(1) / 100000 {
            feeAmount => {
              new ch1 in {
                revAddress!("fromPublicKey", contractConfig.get("fee").nth(0).hexToBytes(), *ch1) |
                for (@revAddr <- ch1) {
                  @return2!((amount - feeAmount, feeAmount, revAddr))
                }
              }
            }
          }
        }
      } |

      // transfers an amount to a temporary escrow purse
      for (@(emitterRevAddress, emitterPurseAuthKey, amount, return) <= transferToEscrowPurseCh) {
        new ch1, ch2, ch3, ch4, ch5, ch6 in {
          registryLookup!(`rho:rchain:revVault`, *ch1) |
          for (@(_, RevVault) <- ch1) {
            @RevVault!("findOrCreate", emitterRevAddress, *ch2) |
            for (@a <- ch2) {
              match a {
                (true, purseVaultEmitter) => {
                  new unf in {
                    @RevVault!("unforgeableAuthKey", *unf, *ch3) |
                    revAddress!("fromUnforgeable", *unf, *ch4) |
                    for (@escrowPurseAuthKey <- ch3; @escrowPurseRevAddr <- ch4) {
                      @RevVault!("findOrCreate", escrowPurseRevAddr, *ch5) |
                      for (@(true, escrowPurseVault) <- ch5) {
                        @purseVaultEmitter!("transfer", escrowPurseRevAddr, amount, emitterPurseAuthKey, *ch6) |
                        for (@escrowTransferResult <- ch6) {
                          match escrowTransferResult {
                            (true, Nil) => {
                              @return!((escrowPurseAuthKey, escrowPurseRevAddr))
                            }
                            _ => {
                              stdout!(escrowTransferResult) |
                              @return!("error: escrow transfer went wrong, invalid rev purse")
                            }
                          }
                        }
                      }
                    }
                  }
                }
                _ => {
                  @return!("error: cannot create purse vault")
                }
              }
            }
          }
        }
      } |

      for (@("PURCHASE", payload, return) <= @boxCh) {
        match payload {
          { "quantity": Int, "contractId": String, "merge": Bool, "purseId": String, "newId": Nil \/ String, "data": _, "purseRevAddr": String, "purseAuthKey": _ } => {
            stdout!(payload) |
            new ch3, ch4, ch5, ch6, ch7, step2Ch, ch20, ch21, ch22, ch23, ch24, step3Ch, rollbackCh, ch30, ch31, ch32, ch33, ch34, ch35, ch36, ch37, step4Ch, ch40, ch41, ch42, ch43, ch44, ch45, step5Ch, ch50, ch51, ch52, ch53, unlock in {

              for (@result <- unlock) {
                @return!(result) |
                @(*vault, "CONTRACT_LOCK", payload.get("contractId"))!(Nil)
              } |

              // STEP 1
              // check box, purse
              getBoxCh!((boxId, *ch3)) |
              for (@box <- ch3) {
                if (box != Nil) {
                  getContractPursesThmCh!((payload.get("contractId"), *ch4)) |
                  getContractPursesDataThmCh!((payload.get("contractId"), *ch5)) |
                  for (@pursesThm <- ch4; @pursesDataThm <- ch5) {
                    if (pursesThm != Nil) {
                      TreeHashMap!("get", pursesThm, payload.get("purseId"), *ch6) |
                      TreeHashMap!("get", pursesDataThm, payload.get("purseId"), *ch7)
                    } else {
                      @return!("error: contract not found")
                    } |
                    for (@purse <- ch6; @purseData <- ch7) {
                      if (purse != Nil) {
                        for (_ <- @(*vault, "CONTRACT_LOCK", payload.get("contractId"))) {
                          step2Ch!((pursesThm, pursesDataThm, purse, purseData))
                        }
                      } else {
                        @return!("error: purse not found")
                      }
                    }
                  }
                } else {
                  @return!("error: CRITICAL box not found")
                }
              } |

              // STEP 2
              // transfer total amount to temporary escrow purse
              // check that both emitter and recipient vault exist
              for (@(pursesThm, pursesDataThm, purse, purseData) <- step2Ch) {
                match (
                  purse.get("price"),
                  purse.get("quantity") > 0,
                  payload.get("quantity") > 0,
                  purse.get("quantity") >= payload.get("quantity")
                ) {
                  (Int, true, true, true) => {
                    registryLookup!(`rho:rchain:revVault`, *ch20) |

                    for (@boxConfig <<- @(*vault, "boxConfig", purse.get("boxId"))) {
                      revAddress!("fromPublicKey", boxConfig.get("publicKey").hexToBytes(), *ch21)
                    } |

                    for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {
                      calculateFeeCh!((payload.get("quantity") * purse.get("price"), contractConfig, *ch22))
                    } |

                    for (@(_, RevVault) <- ch20; @ownerRevAddress <- ch21; @amountAndFeeAmount <- ch22) {
                      match (
                        payload.get("purseRevAddr"),
                        ownerRevAddress,
                        amountAndFeeAmount.nth(0),
                        amountAndFeeAmount.nth(1),
                        amountAndFeeAmount.nth(2)
                      ) {
                        (emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress) => {
                          @RevVault!("findOrCreate", recipientRevAddress, *ch23) |
                          for (@a <- ch23) {
                            match a {
                              (true, purseVaultRecipient) => {
                                transferToEscrowPurseCh!((emitterRevAddress, payload.get("purseAuthKey"), amount + feeAmount, *ch24)) |
                                for (@b <- ch24) {
                                  match b {
                                    String => {
                                      unlock!(b)
                                    }
                                    (escrowPurseAuthKey, escrowPurseRevAddr) => {
                                      step3Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress))
                                    }
                                  }
                                }
                              }
                              _ => {
                                unlock!("error: could not find or create vaults")
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  _ => {
                    unlock!("error: quantity not available or purse not for sale")
                  }
                }
              } |

              // STEP 3
              // listen on rollbackCh and prepare to reset state to original
              // if step 4 or 5 fails
              // 
              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress) <- step3Ch) {
                for (@message <- rollbackCh) {
                  TreeHashMap!("set", pursesThm, purse.get("id"), purse, *ch30) |
                  TreeHashMap!("set", pursesDataThm, purse.get("id"), purseData, *ch31) |
                  if (purse.get("quantity") - payload.get("quantity") == 0) {
                    savePurseInBoxCh!((payload.get("contractId"), purse.get("boxId"), purse.get("id"), true, *ch32))
                  } else {
                    // the purse has not been removed from box
                    ch32!((true, Nil))
                  } |
                  for (_ <- ch30; _ <- ch31; @a <- ch32) {
                    match a {
                      String => {
                        stdout!("error: CRITICAL could not rollback after makePurse error") |
                        unlock!("error: CRITICAL could not rollback after makePurse error")
                      }
                      _ => {
                        @RevVault!("findOrCreate", escrowPurseRevAddr, *ch33) |
                        for (@(true, purseVaultEscrow) <- ch33) {
                          @purseVaultEscrow!("transfer", emitterRevAddress, amount + feeAmount, escrowPurseAuthKey, *ch34) |
                          for (@r <- ch34) {
                            match r {
                              (true, Nil) => {
                                unlock!("error: rollback successful, makePurse error, transaction was rolled backed, emitter purse was reimbursed " ++ message)
                              }
                              _ => {
                                stdout!(r) |
                                stdout!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message) |
                                unlock!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } |
                step4Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress))
              } |

              // STEP 4
              // try to makePurse
              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress) <- step4Ch) {
                for (@makePurseResult <- ch43) {
                  match makePurseResult {
                    String => {
                      rollbackCh!(makePurseResult)
                    }
                    _ => {
                      step5Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress))
                    }
                  }
                } |

                // remove completely purse and create a new one
                // with same id, id may be changed by makePurse
                // depending on fungible or not
                if (purse.get("quantity") - payload.get("quantity") == 0) {
                  TreeHashMap!("set", pursesThm, purse.get("id"), Nil, *ch40) |
                  TreeHashMap!("set", pursesDataThm, purse.get("id"), Nil, *ch41) |
                  removePurseInBoxCh!((purse.get("boxId"), payload.get("contractId"), purse.get("id"), *ch42)) |
                  for (_ <- ch40; _ <- ch41; _ <- ch42) {
                    makePurseCh!((
                      payload.get("contractId"),
                      // keep quantity and type of existing purse
                      purse
                        .set("boxId", boxId)
                        .set("price", Nil)
                        // will only be considered for nft, purchase from purse "0"
                        .set("newId", payload.get("newId")),
                      payload.get("data"),
                      payload.get("merge"),
                      *ch43
                    ))
                  }
                } else {
                  // just update quantity of current purse, and
                  //  create another one with right quantity
                  TreeHashMap!("set", pursesThm, purse.get("id"), purse.set("quantity", purse.get("quantity") - payload.get("quantity")), *ch40) |

                  // purchase NFT from "0", new timestamp
                  if (purse.get("id") == "0") {
                    blockData!(*ch44) |
                    for (_, @timestamp, _ <- ch44) {
                      ch45!(timestamp)
                    }
                  // purchase ft or NFT not "0"
                  // duplicate timestamp
                  } else {
                    ch45!(purse.get("timestamp"))
                  } |

                  for (@timestamp <- ch45) {
                    for (_ <- ch40) {
                      makePurseCh!((
                        payload.get("contractId"),
                        purse
                          .set("boxId", boxId)
                          .set("quantity", payload.get("quantity"))
                          .set("price", Nil)
                          .set("timestamp", timestamp)
                          // will only be considered for nft, purchase from purse "0"
                          .set("newId", payload.get("newId")),
                        payload.get("data"),
                        payload.get("merge"),
                        *ch43
                      ))
                    }
                  }
                }
              } |

              // STEP 5
              // everything went ok, do final payment
              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feeRevAddress) <- step5Ch) {
                @RevVault!("findOrCreate", escrowPurseRevAddr, *ch50) |
                for (@(true, purseVaultEscrow) <- ch50) {
                  @purseVaultEscrow!("transfer", recipientRevAddress, amount, escrowPurseAuthKey, *ch51) |
                  for (@r <- ch51) {
                    match r {
                      (true, Nil) => {
                        if (feeAmount != 0) {
                          @purseVaultEscrow!("transfer", feeRevAddress, feeAmount, escrowPurseAuthKey, *ch53) |
                          for (@transferFeeReturn <- ch53) {
                            match transferFeeReturn {
                              (true, Nil) => {
                                stdout!("fee transfer successful")
                              }
                              _ => {
                                stdout!("error: CRITICAL could not transfer fee")
                              }
                            }
                          }
                        } |
                        unlock!((true, Nil))
                      }
                      _ => {
                        stdout!("error: CRITICAL, makePurse went fine, but could not do final transfer") |
                        rollbackCh!("error: CRITICAL, makePurse went fine, but could not do final transfer")
                      }
                    }
                  }
                }
              }
            }
          }
          _ => {
            @return!("error: invalid payload")
          }
        }
      }
    } |

    insertArbitrary!(bundle+{*entryCh}, *entryUriCh) |

    for (entryUri <- entryUriCh) {
      basket!({
        "status": "completed",
        "registryUri": *entryUri
      }) |
      stdout!(("rchain-token master registered at", *entryUri))
    }
  }
}
