new basket,
  splitReturnCh,
  savePurseReturnCh,
  boxCh,
  readReturnCh,
  stdout(`rho:io:stdout`),
  deployerId(`rho:rchain:deployerId`),
  registryLookup(`rho:registry:lookup`)
in {

  @(*deployerId, "rho:id:FROM_BOX_REGISTRY_URI")!(({ "type": "READ_PURSES" }, *boxCh)) |

  for (purses <- boxCh) {
    match *purses.get(`rho:id:REGISTRY_URI`).get("PURSE_ID") {
      Nil => {
        basket!({ "status": "failed", "message": "purse not found" }) |
        stdout!(("failed", "purse not found"))
      }
      purse => {
        @(purse, "SPLIT")!((SPLIT_PURSE_QUANTITY, *splitReturnCh)) |
        for (r <- splitReturnCh) {
          match *r {
            String => {
              basket!({ "status": "failed", "message": *r }) |
              stdout!(("failed", *r))
            }
            (true, newPurse) => {
              @(newPurse, "READ")!((Nil, *readReturnCh)) |
              for (@properties <- readReturnCh) {
                /*
                  Save new purse without joining it (DEPOSIT) to a purse with same type
                */
                @(*deployerId, "rho:id:FROM_BOX_REGISTRY_URI")!((
                  { "type": "SAVE_PURSE_SEPARATELY", "payload": { "registryUri": `rho:id:REGISTRY_URI`, "purse": newPurse } },
                  *savePurseReturnCh
                )) |
                for (r2 <- savePurseReturnCh) {
                  match *r2 {
                    String => {
                      stdout!("DANGER completed, purse split but could not save to box") |
                      basket!({ "status": "failed", "message": "DANGER completed, purse split but could not save to box" })
                    }
                    _ => {
                      stdout!("completed, purse split and saved in box") |
                      basket!({ "status": "completed" })
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
