
new
  basket,
  revVaultPurseCh,
  priceCh,
  quantityCh,
  publicKeyCh,
  newIdCh,
  dataCh,
  returnCh,
  purseIdCh,
  registryUriCh,
  revAddressCh,
  boxExistsCh,
  boxValuesCh,
  contractExistsCh,
  contractValuesCh,
  proceed1Ch,
  proceed2Ch,
  registryLookup(`rho:registry:lookup`),
  deployerId(`rho:rchain:deployerId`),
  stdout(`rho:io:stdout`),
  revAddress(`rho:rev:address`)
in {

  /*
    The 5 following values must be filled with proper values
  */
  // Registry URI of the contract
  registryUriCh!!(`rho:id:REGISTRY_URI`) |
  // Unique ID of the token you want to purchase
  purseIdCh!!("PURSE_ID") |
  // New ID only used if fungible = false, if fungible = true set to Nil
  newIdCh!!("NEW_ID") |
  // Per token price, make sure it is accurate
  priceCh!!(PRICEE) |
  // Quantity you want to purchase, make sure enough are available
  quantityCh!!(QUANTITY) |
  // Your public key
  // If the transfer fails, refund will go to the corresponding REV address
  publicKeyCh!!("PUBLIC_KEY") |
  // data
  dataCh!("PURCHASE_PURSE_DATA") |

  registryLookup!(`rho:id:TO_BOX_REGISTRY_URI`, *boxExistsCh) |
  registryLookup!(`rho:id:REGISTRY_URI`, *contractExistsCh) |
  for (boxExists <- boxExistsCh; contractExists <- contractExistsCh) {
    boxExists!(("PUBLIC_READ", Nil, *boxValuesCh)) |
    contractExists!(("PUBLIC_READ", Nil, *contractValuesCh)) |
    for (@contractValues <- contractValuesCh; @boxValues <- boxValuesCh ) {
      match contractValues.get("version") == boxValues.get("version") {
        true => {
          proceed1Ch!(Nil)
        }
        true => {
          basket!({ "status": "failed", "message": "box and contract don't have the same version, cancelled purchase and payment" }) |
          stdout!(("failed", "box and contract don't have the same version, cancelled purchase and payment"))
        }
      }
    }
  } |

  registryLookup!(`rho:rchain:revVault`, *revVaultPurseCh) |

  /*
    Create a vault/purse that is just used once (purse)
  */
  for(@(_, *RevVaultPurse) <- revVaultPurseCh; _ <- proceed1Ch) {
    new unf, purseRevAddrCh, purseAuthKeyCh, purseVaultCh, revAddressCh, RevVaultCh in {
      revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |
      RevVaultPurse!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |
      for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {

        stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |

        RevVaultPurse!("findOrCreate", purseRevAddr, *purseVaultCh) |

        for (
          @(true, purseVault) <- purseVaultCh;
          @publicKey <- publicKeyCh;
          @purseId <- purseIdCh;
          @registryUri <- registryUriCh;
          @price <- priceCh;
          @quantity <- quantityCh;
          @newId <- newIdCh;
          @data <- dataCh
        ) {

          match {
            "publicKey": publicKey,
            "price": price,
            "quantity": quantity,
            "purseId": purseId,
            "newId": newId,
          } {
            {
              "publicKey": String,
              "price": Int,
              "quantity": Int,
              "purseId": String,
              "newId": String,
            } => {
              proceed2Ch!(Nil)
            }
            _ => {
              basket!({ "status": "failed", "message": "error: invalid payload, cancelled purchase and payment" }) |
              stdout!(("failed", "error: invalid payload, cancelled purchase and payment"))
            }
          } |

          for (_ <- proceed2Ch) {

            revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |

            registryLookup!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh; deployerRevAddress <- revAddressCh) {
              // send price * quantity REV in purse
              match (
                *deployerRevAddress,
                purseRevAddr,
                price * quantity
              ) {
                (from, to, amount) => {
                  new vaultCh, revVaultkeyCh in {
                    @RevVault!("findOrCreate", from, *vaultCh) |
                    @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                    for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {

                      stdout!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |

                      new resultCh, entryCh in {
                        @vault!("transfer", to, amount, *key, *resultCh) |
                        for (@result <- resultCh) {

                          stdout!(("Finished transfer of ", amount, "REV to", to, "result was:", result)) |
                          match result {
                            (true, Nil) => {
                              registryLookup!(registryUri, *entryCh) |
                              for(entry <- entryCh) {
                                entry!(("PUBLIC_PURCHASE", {
                                    "quantity": quantity,
                                    "purseId": purseId,
                                    "newId": newId,
                                    "data": data,
                                    "box": `rho:id:TO_BOX_REGISTRY_URI`,
                                    "publicKey": publicKey,
                                    "purseRevAddr": purseRevAddr,
                                    "purseAuthKey": purseAuthKey
                                  },
                                  *returnCh
                                )) |
                                for (resp <- returnCh) {
                                  match *resp {
                                    (true, purse) => {
                                      new readReturnCh, boxEntryCh, receivePursesReturnCh in {
                                        entry!(("PUBLIC_READ", Nil, *readReturnCh)) |
                                        for (@current <- readReturnCh) {
                                          match "ACTION_AFTER_PURCHASE" {
                                            "PUBLIC_RECEIVE_PURSE" => {
                                              registryLookup!(`rho:id:TO_BOX_REGISTRY_URI`, *boxEntryCh) |
                                              for (boxEntry <- boxEntryCh) {
                                                boxEntry!(("PUBLIC_RECEIVE_PURSE", 
                                                  {
                                                    "registryUri": current.get("registryUri"),
                                                    "purse": purse,
                                                  },
                                                  *receivePursesReturnCh
                                                ))
                                              }
                                            }
                                            "SAVE_PURSE_SEPARATELY" => {
                                              @(*deployerId, "rho:id:TO_BOX_REGISTRY_URI")!((
                                                {
                                                  "type": "SAVE_PURSE_SEPARATELY",
                                                  "payload": {
                                                    "registryUri": current.get("registryUri"),
                                                    "purse": purse,
                                                  } 
                                                },
                                                *receivePursesReturnCh
                                              ))
                                            }
                                          } |
                                          for (r <- receivePursesReturnCh) {
                                            match *r {
                                              String => {
                                                basket!({ "status": "failed", "message": *resp }) |
                                                stdout!(("failed", *resp))
                                              }
                                              _ => {
                                                basket!({ "status": "completed" }) |
                                                stdout!("purchase went well")
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    _ => {
                                      new refundPurseBalanceCh, refundResultCh in {
                                        @purseVault!("balance", *refundPurseBalanceCh) |
                                        for (@balance <- refundPurseBalanceCh) {
                                          // the refund was successful
                                          if (balance == 0) {
                                            basket!({ "status": "failed", "message": *resp }) |
                                            stdout!(("failed", *resp))
                                          } else {
                                            @purseVault!("transfer", from, balance, purseAuthKey, *refundResultCh) |
                                            for (result <- refundResultCh)  {
                                              match *result {
                                                (true, Nil) => {
                                                  basket!({ "status": "failed", "message": "purchase failed but was able to refund " ++ balance }) |
                                                  stdout!(("failed", "purchase failed but was able to refund " ++ balance))
                                                }
                                                _ => {
                                                  basket!({ "status": "failed", "message": "purchase failed and was NOT ABLE to refund " ++ balance }) |
                                                  stdout!(("failed", "purchase failed and was NOT ABLE to refund " ++ balance))
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            _ => {
                              basket!({ "status": "failed", "message": result }) |
                              stdout!(("failed", result))
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}